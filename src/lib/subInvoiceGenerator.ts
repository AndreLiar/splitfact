import { PrismaClient } from '@prisma/client';
import { Resend } from 'resend';

const prisma = new PrismaClient();
const resend = new Resend(process.env.RESEND_API_KEY || 'fake-api-key-for-build');

interface GenerateSubInvoicesParams {
  invoiceId: string;
  sessionUserId: string;
  collectiveId?: string; // Optional, for collective-specific logic
}

export async function generateSubInvoices({ invoiceId, sessionUserId, collectiveId }: GenerateSubInvoicesParams) {
  const invoice = await prisma.invoice.findUnique({
    where: {
      id: invoiceId,
      ...(collectiveId && { collectiveId }), // Conditionally add collectiveId to where clause
    },
    include: {
      shares: {
        include: {
          user: true, // Include user to get email for sub-invoice receiver
        },
      },
      client: true, // Include client for email content
      collective: true, // Include collective for email content
    },
  });

  if (!invoice) {
    throw new Error('Invoice not found');
  }

  const subInvoicesToCreateWithShareId: Array<{ subInvoiceData: any; shareId: string; receiverEmail: string }> = [];

  // Optimize N+1 query: Collect all receiver user IDs
  const receiverUserIds = invoice.shares
    .filter(share => share.userId !== sessionUserId && !share.autogeneratedInvoiceId)
    .map(share => share.userId);

  const receiverUsers = await prisma.user.findMany({
    where: {
      id: {
        in: receiverUserIds,
      },
    },
    select: {
      id: true,
      email: true,
    },
  });

  const receiverUserMap = new Map(receiverUsers.map(user => [user.id, user]));

  for (const share of invoice.shares) {
    // Ensure sub-invoice is only created for members other than the invoice issuer
    // and if a sub-invoice hasn't been generated for this share yet
    if (share.userId !== sessionUserId && !share.autogeneratedInvoiceId) {
      const receiverUser = receiverUserMap.get(share.userId);

      if (receiverUser?.email) {
        const subInvoiceData = {
          issuerId: sessionUserId, // The invoice issuer issues the sub-invoice
          receiverId: share.userId, // The collaborating freelancer receives the sub-invoice
          parentInvoiceId: invoice.id,
          amount: share.calculatedAmount,
          status: "draft",
          paymentStatus: "pending",
          description: share.description, // Pass share description to sub-invoice
          legalMentions: invoice.legalMentions, // Pass main invoice legal mentions to sub-invoice
        };

        subInvoicesToCreateWithShareId.push({
          subInvoiceData,
          shareId: share.id,
          receiverEmail: receiverUser.email,
        });
      }
    }
  }

  if (subInvoicesToCreateWithShareId.length === 0) {
    return { message: 'No sub-invoices to generate for this invoice.', subInvoices: [] };
  }

  const createdSubInvoices = await prisma.$transaction(async (tx) => {
    const created = await Promise.all(
      subInvoicesToCreateWithShareId.map((item) =>
        tx.subInvoice.create({ data: item.subInvoiceData })
      )
    );

    for (let i = 0; i < created.length; i++) {
      const createdSubInvoice = created[i];
      const originalShareId = subInvoicesToCreateWithShareId[i].shareId;

      await tx.invoiceShare.update({
        where: { id: originalShareId },
        data: { autogeneratedInvoiceId: createdSubInvoice.id },
      });
    }
    return created;
  });

  // TODO: For production, consider implementing a more robust email sending mechanism
  // (e.g., a dedicated queue, retry logic) to ensure delivery and handle failures gracefully.
  // Send email notifications outside the transaction to avoid blocking
  for (let i = 0; i < createdSubInvoices.length; i++) {
    const createdSubInvoice = createdSubInvoices[i];
    const receiverEmail = subInvoicesToCreateWithShareId[i].receiverEmail;

    if (receiverEmail) {
      console.log(`Attempting to send email to: ${receiverEmail}`);
      try {
        const emailData = {
          from: process.env.EMAIL_FROM as string,
          to: receiverEmail,
          subject: `New Sub-Invoice from ${invoice.issuerName} for Invoice ${invoice.invoiceNumber}`,
          html: `<p>A new sub-invoice has been generated by ${invoice.issuerName} for your share in invoice ${invoice.invoiceNumber}.</p>
                 <p>Amount: ${createdSubInvoice.amount}â‚¬</p>
                 <p>You can view and download it from your dashboard.</p>
                 <p>Sub-Invoice ID: ${createdSubInvoice.id}</p>`,
        };
        console.log("Email details:", emailData);
        
        // Skip email sending during build or if no API key
        if (!process.env.RESEND_API_KEY || process.env.RESEND_API_KEY === 'fake-api-key-for-build') {
          console.log('Skipping email send (no API key configured)');
          return;
        }
        
        const response = await resend.emails.send(emailData);
        console.log(`Email sent successfully to ${receiverEmail}:`, response);
      } catch (emailError) {
        console.error(`Error sending email to ${receiverEmail}:`, emailError);
      }
    } else {
      console.log(`Skipping email for sub-invoice ${createdSubInvoice.id} as receiverEmail is not available.`);
    }
  }

  return { message: 'Sub-invoices generated successfully', subInvoices: createdSubInvoices };
}